import FormalVerifML.definitions
import FormalVerifML.ml_properties

open FormalVerifML

namespace FairnessExample

/--
We assume a finite population of individuals.
--/
variable (I : List Individual)

axiom Individual : Type
axiom protected_group : Individual → Prop

/--
A simple logistic regression model (could be generated by the translator).
--/
def exampleLogisticModel : LinearModel :=
  { inputDim := 2, weights := #[0.5, 0.5], bias := 0.0 }

/--
The classification function: given features for an individual, returns 1 if the logistic model output is nonnegative.
--/
def classify (ind : Individual) (toFeatures : Individual → Array Float) : Nat :=
  let features := toFeatures ind
  let z := evalLinearModel exampleLogisticModel features
  if z ≥ 0 then 1 else 0

/--
Define an empirical version of demographic parity over a finite list of individuals.
It asserts that the proportion of individuals classified as 1 among those satisfying
the protected predicate equals that among the non-protected individuals.
--/
def empirical_demographic_parity (f : Individual → Nat) (protected : Individual → Prop) : Prop :=
  let ps := I.filter (λ ind, protected ind)
  let nps := I.filter (λ ind, ¬ protected ind)
  let p1 := if ps.length = 0 then 0 else (ps.filter (λ ind, f ind = 1)).length / ps.length
  let p2 := if nps.length = 0 then 0 else (nps.filter (λ ind, f ind = 1)).length / nps.length
  p1 = p2

/--
Prove that if the classifier is constant (always returns 1), then the empirical demographic parity holds.
--/
theorem example_demographic_parity (toFeatures : Individual → Array Float)
  (h : ∀ ind, classify ind toFeatures = 1) :
  empirical_demographic_parity (classify · toFeatures) protected_group :=
begin
  -- Let ps and nps be the protected and non-protected subpopulations.
  let ps := I.filter (λ ind, protected_group ind),
  let nps := I.filter (λ ind, ¬ protected_group ind),
  have hps : (ps.filter (λ ind, classify ind toFeatures = 1)).length = ps.length,
  { apply List.length_filter_eq_length,
    intros ind hi, apply h ind },
  have hnps : (nps.filter (λ ind, classify ind toFeatures = 1)).length = nps.length,
  { apply List.length_filter_eq_length,
    intros ind hi, apply h ind },
  -- In either case (empty or nonempty group), the computed proportions are equal.
  by_cases h_ps : ps.length = 0,
  { by_cases h_nps : nps.length = 0; simp [empirical_demographic_parity, h_ps, h_nps] },
  { by_cases h_nps : nps.length = 0,
    { simp [empirical_demographic_parity, h_ps, h_nps] },
    { simp [empirical_demographic_parity, hps, hnps] } }
end

end FairnessExample
